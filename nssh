#!/usr/bin/env python3

# This is a parallel wrapper around SSH to be used on a cluster.
# Wait, isn't this just a copy of pssh? Yes, yes it is. 
# Written to be slightly easier to use, and also works on a Solaris box I have lurking about.

import argparse
import os
import getpass
import asyncio
from asyncio.subprocess import PIPE

class TColors:
    """
    A bunch of escape sequences for terminal formatting.
    """

    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    def demo():
        print(TColors.PURPLE + 'purple')
        print(TColors.BLUE + 'blue')
        print(TColors.GREEN + 'green')
        print(TColors.YELLOW + 'yellow')
        print(TColors.RED + 'red' + TColors.END)
        print(TColors.BOLD + 'bold')
        print(TColors.UNDERLINE + 'underline')
        print(TColors.END + 'end')


def main(): 
    parser = argparse.ArgumentParser(description='Run an SSH command in parallel across a set of nodes')
    parser.add_argument('nodes', nargs=1, type=str,
                        help='A comma-seperated list of nodes or path to a file with a nodelist (one line per node).')
    parser.add_argument('command', nargs='+', type=str, 
                        help='Command to be run')
    parser.add_argument('-u', '--user', nargs=1, type=str, default=getpass.getuser(), 
                        help='User to connect as. Defaults to current user.')
    parser.add_argument('-p', '--port', nargs=1, type=int, default=22,
                        help='Port to connect over')
    parser.add_argument('-o', '--option', nargs=1, 
                        help='Options to be passed to SSH')
    argv = parser.parse_args()

    # get all nodes to ssh to
    nodes_arg = argv.nodes[0]
    if os.path.exists(nodes_arg):
        # we were given a nodelist file
        nodes = []
        with open(nodes_arg) as nodelist:
            for line in nodelist:
                nodes.append(line.strip())
    else:
        # we were given a comma-separated list of nodes
        nodes = nodes_arg.split(',')

    # create async tasks and run them
    loop = asyncio.get_event_loop()
    tasks = [asyncio.async(ssh(node, ' '.join(argv.command))) for node in nodes]
    futures, empty = loop.run_until_complete(asyncio.wait(tasks))
    loop.close()

    print(futures)
    print(tasks)

    # for future in tasks:
    #     print(type(future.result()))
    #     print(future.result())

    # print(asyncio.gather(tasks))


@asyncio.coroutine
def ssh(host, command):
    """
    This runs wraps and runs the SSH command for each node
    """

    print('HOST {} - starting task {}'.format(host, command))  # debug
    
    process = yield from asyncio.create_subprocess_shell(command, stdout=PIPE, stderr=PIPE)
    yield from process.wait()  # wait for process to finish
    
    print('HOST {} - finished with exit code {}'.format(host, process.returncode))  # debug
    #return process.stdout.read()
    return process
    

if __name__ == '__main__':
    main()
